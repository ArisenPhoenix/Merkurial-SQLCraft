// Merkurial SQLCraft
// Copyright (c) 2025 Brandon M. Marcure
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.


import FETCH from "../../APIS/FETCH";
import {
  Schema,
  ForeignKeyMap,
  PrimaryKey,
  Messenger, 
  TableResponse,
  ColumnInput,
  None,
  Row,
  Rows,
  Value,
  RowEntry,
  Options,
  ColumnName,
  ColumnEntry
} from "../../type_defs/SQL_TYPES";


 
import {
  getForeignKey,
  getPrimaryKey,
  paramsIncludeAutoGenId,
} from "../../helpers/checkAutoGenId";

import SQL_ROW from "./SQL_ROW";
import ARGS from "../../helpers/postgreArgs";
import { HttpMethod } from "../../type_defs/api";

const { numeric, jsonb, unique } = ARGS

type query = {query: string, type?: string | undefined}
type Properties = {}

export default class SQL_BASE {
  // Must Be Supplied
  tableName: string;
  tableSchema: Schema;
  callAddress: string;
  isPopulated: true | None;
  
  // Optionally Supplied
  messenger: Messenger | None;

  // Wiil Be Extrapolated From Schema
  primaryKey: PrimaryKey;
  columnNames: string[];
  foreignKeyColumnNames: string[];
  isIdAutoGenerated: string | false;
  containsArray: boolean;

  // Can Be Extrapolated Elsewhere
  foreignKeyMap: ForeignKeyMap | None;
  rawRows: Row[] | Array<Row>   // For batch operations and perhaps rollbacks
  sqlRows: SQL_ROW[] // For holding actual table data and output of said data

  returning: boolean
  deleting: boolean
  updating: boolean
  adding: boolean
  lastQuery: string | undefined

  constructor(
    tableName: string,
    tableSchema: Schema,
    callAddress: string,
    messenger: Messenger | None,
    primaryKey: PrimaryKey | null = null,
    foreignKeyMap: ForeignKeyMap | null | false = false,
    isIdAutoGenerated: string | false = false
    
  ) {
    this.tableName = tableName; 
    this.tableSchema = tableSchema;
    this.callAddress = callAddress;
    this.messenger = messenger;
    this.isPopulated = false;
    this.primaryKey = primaryKey;
    this.foreignKeyMap = foreignKeyMap == null ? {} : foreignKeyMap
    this.columnNames = [];
    this.foreignKeyColumnNames = [];
    this.isIdAutoGenerated = isIdAutoGenerated
    this.rawRows = []
    this.containsArray = false
    this.returning = false
    this.deleting = false
    this.updating = false
    this.adding = false
    this.construct();
    this.lastQuery = undefined
  }

  construct() {
    if (this.tableSchema.length > 0) {
      this.extrapolateData(this.tableSchema);
    }
  }

  properties = (): Properties => {
    const props = {
      tableName: this.tableName,
      tableSchema: this.tableSchema,
      callAddress: this.callAddress,
      primaryKey: this.primaryKey,
      foreignKeyMap: this.foreignKeyMap,
      columnNames: this.columnNames,
      foreignKeyColumnNames: this.foreignKeyColumnNames,
    }
    return props
  };

  private extrapolateData = (tableSchema: Schema) => {
    if (
      !this.primaryKey ||
      this.primaryKey == null ||
      !this.columnNames ||
      this.columnNames == null ||
      this.columnNames.length === 0 ||
      !this.foreignKeyColumnNames ||
      this.foreignKeyColumnNames == null || 
      this.foreignKeyColumnNames.length === 0 ||  
      !this.isIdAutoGenerated
    ) {
      tableSchema.forEach((columnData) => {
        // console.log(column)
        const {column, params} = columnData
        this.columnNames.push(column);
        const primaryKey = getPrimaryKey(params)
        const foreignKey = getForeignKey(params)
        if (JSON.stringify(params).includes("[]")){
          this.containsArray = true
        }
        if (foreignKey && primaryKey){
          throw Error("There Cannot Be Both A Primary Key And A Foreign Key Assigned To A Column")
        } else {
          if (this.primaryKey == null && primaryKey){
            this.primaryKey = column
            this.isIdAutoGenerated = paramsIncludeAutoGenId(params)
          } 
          else if (this.primaryKey && primaryKey) {
            throw new Error("A Table May Only Have Up To 1 Primary Key");
          } 
          if (foreignKey){
            this.foreignKeyColumnNames.push(column);
            this.foreignKeyColumnNames = new Array(...new Set(this.foreignKeyColumnNames))
            this.foreignKeyMap[column] = params;
          }
        }
        if (!this.primaryKey) {
          throw new Error("Your Table Must Contain A PRIMARY KEY");
        }
        
      });
    }
  };

  compareAllColumnInputs = (arr: ColumnInput[]) => {
    let colNames = [];
    let colVals = [];
    for (let i = 0; i < arr.length; i++) {
      const [key, value] = Object.entries(arr[i]);
      colNames.push(key);
      colVals.push(value);
    }

    let text = "";
    for (let i = 0; i < colNames.length; i++) {
      const col = colNames[i];
      const value = colVals[i];
      const addend = i === colNames.length - 1 ? "" : "AND";
      text += `"${col}" = '${value}' ${addend} `;
    }
    return text;
  };

  findRowByColumnsAndValues = async (arr: ColumnInput[], callAddress=this.callAddress, options: Options | undefined) => {

    let query = this.compareAllColumnInputs(arr);
    query = this.HANDLE_SUPPLEMENTARY(query, options)
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      callAddress,
      "findRowByColumnsAndValues"
    );
    return response;
  };

  call = async (
    query: query,
    method: HttpMethod,
    address: string,
    callingFunction: string | null | undefined = null
  ) => {
    const response = await FETCH (
      address,
      method,
      { query: query.query, type: query.type },
      callingFunction
    );
    
    if (response.ok) {
      this.lastQuery = query.query
      // this.isPopulated = method !== "DELETE" ? true : false;
      if (this.messenger != null) {
        response.message &&
          this.messenger &&
          this.messenger(`Table ${this.tableName} ${response.message}`);
      }
      return response;
    }
  };

  

  query = async (
    query: query,
    method: HttpMethod = "POST",
    callAddress: string = this.callAddress,
    callingFunction: string = "SQL_BASE.query"
  ) => {
    const queryData = {query: query.query, type: query.type}
    const res = await this.call(
      queryData,
      method,
      callAddress,
      callingFunction
    );
    this.HANDLE_RESPONSE(res)

    return res;
  };


  IS_JSON = (potentialJsonString: string) => {
    try {
      return JSON.parse(potentialJsonString)
      
    } catch (err) {
      return false
    }
  }

  GET_UNIQUE_FROM_SCHEMA = (data: RowEntry) => {
    for (const entry in Object.keys(data)){
      if (unique in this.tableSchema[entry]){
        return entry
      }
    }
    return false
  }

  getAtomicIdentifier(row: RowEntry): { column: string; value: any } {
    if (this.primaryKey && row[this.primaryKey] !== undefined) {
      return { column: this.primaryKey, value: row[this.primaryKey] };
    }
  
    for (const { column, params } of this.tableSchema) {
      if (params.includes(unique) && row[column] !== undefined) {
        return { column, value: row[column] };
      }
    }
  
    throw new Error("Row must contain a primary key or a unique column to perform an atomic delete.");
  }

    
  Where = (columnName: ColumnName, value: Value) => {
    let val = value;
    if (typeof val === "string" || typeof val === "number" || typeof val === "boolean") {
      val = this.HANDLE_INSERT_NUMBER_OR_STRING(val, `'`)
    } else if (Array.isArray(val)){
      val = this.HANDLE_ARRAY_COLUMN_VALUES(val)
    } 
    return `"${columnName}" = ${val} `;
  };

  TableWhere = (columnName: ColumnName, tableName: string, value: Value) => {
    let val = value;
    if (typeof val == "string") {
      val = `'${value}'`;
    }
    return `"${columnName}" = '${tableName}'.${val}`;
  };

  Wheres = (args: ColumnInput) => {
    let query = "WHERE ";
    const entries = Object.entries(args);
    entries.forEach((entry, index) => {
      const addend = index === entries.length - 1 ? "" : "AND ";
      query += this.Where(entry[0], entry[1]) + addend;
    });
    return query;
  };

  SET = (columnName: ColumnName, value: any, isJsonB: boolean) => {
    if (isJsonB){
      return `${columnName} = ${this.HANDLE_INSERT_JSON_B(value)}`
    } else if (Array.isArray(value)){
      return `${columnName} = ${this.HANDLE_INSERT_ARRAY(value)} `
    } 
    return `${columnName} = ${this.HANDLE_INSERT_NUMBER_OR_STRING(value, `'`)} `
  }

  SETS = (itemsToSet: RowEntry, jsonColumnNames: string[] | undefined) => {
    let setQuery = this.UPDATE_ROW_STRING()
    const entries = Object.entries(itemsToSet)
    entries.forEach((entry, index) => {
      const isJsonB = jsonColumnNames.includes(entry[0])
      const addend = index === entries.length - 1 ? "" : ", ";
      setQuery += this.SET(entry[0], entry[1], isJsonB) + addend;
    })
    return setQuery
  }

  HANDLE_INSERT_NUMBER_OR_STRING = (value: Value, quote: string) => {
    if (typeof value == "string"){
      return `${quote}${value}${quote}`
    } else if (typeof value == "number"){
      return value
    } else {
      return value
    }
  }

  HANDLE_INSERT_ARRAY = (array: Array<string|number>) => {
    const newArray = array.map((item) => {
      if (Array.isArray(item)){
        return this.HANDLE_INSERT_ARRAY(item)
      } else {
        return this.HANDLE_INSERT_NUMBER_OR_STRING(item, `'`)
      }
    })

    let sqlArray = "'{"
    sqlArray += newArray.join(",")
    sqlArray += "}'"
    return sqlArray
  }

  HANDLE_INSERT_JSON_B = (object: {}) => {
    return `'${JSON.stringify(object)}'::jsonb`
  }

  HANDLE_SUPPLEMENTARY = (initial_query: string, options: Options) => {
    let query = initial_query
    if (options.groupBy && typeof options.groupBy === "string") {
      query += ` GROUP BY "${options.groupBy}"`
    }
    if (options.orderBy && typeof options.orderBy === "string"){
      query += ` ORDER BY "${options.orderBy}"`
    }
    if (options.limit && typeof options.limit === "number"){
      query += ` LIMIT ${options.limit}`
    } if (options.returning && typeof options.returning === "string"){
      this.returning = true
      query += ` RETURNING ${options.returning}`
    }
    this.returning = false;
    return query
  }

  HANDLE_INSERT_ARRAY_DATA = (array: any[], quote: string, jsonColumns: number[] | undefined = undefined) => {
    let string = ""
    array.forEach((value, index) => {
      if (jsonColumns && Array.isArray(jsonColumns) && jsonColumns.includes(index)){
        string += this.HANDLE_INSERT_JSON_B(value)
      }
      
      else if (Array.isArray(value)){
        string += this.HANDLE_INSERT_ARRAY(value)
      } else {
        string += this.HANDLE_INSERT_NUMBER_OR_STRING(value, quote)
      }
      if (index !== array.length - 1){
        string += ', '
      }
    })
    return string
  }
  
  HANDLE_ARRAY_COLUMN_VALUES = (rowColumnValue: Value | Value[]) => {
    if (Array.isArray(rowColumnValue)){
      const values = rowColumnValue.map((value: any) => {
        if ( value && typeof value === "string" && !Number.isNaN(Number(value))){
          return Number(value)
        } else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean"){
          return this.HANDLE_INSERT_NUMBER_OR_STRING(value, `'`)
        } else {
          if (value){
            return value
          } else {
            throw Error(`Cannot Interpret Column Value Of Type ${typeof value}`)
          }
        }
      })
      return values
    } else {
      return rowColumnValue
    }
  } 

  HANDLE_ROWS = (rows: Rows): any => {
    const ROWS_FINAL = rows.map((row: Row) => {
      let newRow = row
      if (this.containsArray){
        for (const column in row){
          const rowColumnValue = row[column]
          const UpdatedRowValue = this.HANDLE_ARRAY_COLUMN_VALUES(rowColumnValue)
          newRow[column] = UpdatedRowValue
        }
      }  
      
      return newRow
  })

  
  return ROWS_FINAL
  
}

  DELETE_ROW_STRING = () => {
    const query = `DELETE FROM ${this.tableName} `
    return query
  }

  UPDATE_ROW_STRING = () => {
    const query = `UPDATE ${this.tableName} SET `
    return query
  }

  

  protected HANDLE_RESPONSE = (
    response: any,
    deleted: boolean = false,

  ): TableResponse => {
    const okay = response.ok
    // console.log("HANDLE_RESPONSE response: ", response)
    if (okay && Array.isArray(response.response?.rows)){
      const rows: Rows = response.response.rows;
      const error = response.response?.err ? response.response.err : false
      const message = response.response?.message ? response.response.message : false

     
      
      if (deleted) {
        this.isPopulated = false;
        return {
          rows,
          ok: okay,
          err: error,
          message: message || "Deleted successfully.",
          isPopulated: false,
        };
      }

      
      // if (response?.ok && response?.response?.rows) {
        this.isPopulated = (Array.isArray(rows) && rows.length > 0)
        const res: TableResponse = {ok: okay, rows: rows, err: error, message: message, isPopulated: this.isPopulated}

        if (!this.isPopulated) {
          res.message = "No rows returned"
          // return {
          //   ok: okay,
          //   err: error,
          //   rows: [],
          //   isPopulated: this.isPopulated,
          //   // res.message = "No rows returned",
          //   message: message || "No rows returned.",
          // };
        }
    
        const updatedRows = this.HANDLE_ROWS(rows);
    
        this.tableSchema.forEach(({ column, params }) => {
          if (params.includes(numeric)) {
            updatedRows.forEach((row: Row) => {
              row[column] = Number(row[column]);
            });
          }
        });
    
        this.rawRows = [...updatedRows];
        
        // return {
        //   rows: this.rawRows,
        //   ok: okay,
        //   err: error,
        //   message: message,
        //   isPopulated: this.isPopulated,
        // };
      // }
    
      // If deleting, but the server returns OK without rows
    
      // Known error format
      // if (response?.message) {
      //   return {
      //     ok: okay,
      //     err: error,
      //     rows: this.rawRows,
      //     isPopulated: this.isPopulated,
      //     message: message,
      //   };
      // }
    
      // Fallback: malformed response
      // return {
      //   ok: okay,
      //   err: "Something Went Wrong",
      //   message: "Something Went Wrong",
      //   rows: this.rawRows,
      //   isPopulated: this.isPopulated,
      //   // hasTable: this.isPopulated ? true : false
      // };
      return res
    } else {
      return {
        ok: okay,
        err: "Response Failed",
        message: "Response Failed",
        rows: this.sqlRows,
        isPopulated: this.isPopulated
      }
    }
    
  };

  }


// export default SQL_BASE;
//   protected HANDLE_RESPONSE = ( 
//     response: any,
//     deleted: boolean = false
//   ): TableResponse => {
//     if (response?.response && !response?.message) {
//       if (!deleted) {
//         const rows: Rows = response.response?.rows;
//         if (!rows){
//           return {
//             rows: this.rawRows,
//             ok: false,
//             err: "There Were No Rows",
//             message: response.message,
//             isPopulated: true,
//           }
//         }
        
//         this.isPopulated = Array.isArray(rows) && rows.length > 0;
//         if (!this.isPopulated) {return {ok: true, err: false, rows: [], isPopulated: false, message: response.message || "No rows returned."};}
        
//         const updatedRows = this.HANDLE_ROWS(rows);
//         this.tableSchema.forEach(({ column, params }) => {
//           if (params.includes(numeric)) {
//             updatedRows.forEach((row: Row) => {
//               row[column] = Number(row[column]);
//             });
//           }
//         });

//         this.rawRows = [...updatedRows];

//         return {
//           rows: this.rawRows,
//           ok: true,
//           err: false,
//           message: response.message,
//           isPopulated: true,
//         };

//       }

//     // If deleting, but the server returns OK without rows
//     if (deleted && response?.ok) {
//       return {
//         ok: true,
//         err: false,
//         rows: [],
//         message: response.message || "Deleted successfully.",
//         isPopulated: this.isPopulated,
//       };
//     }

//     // Known error format
//     if (response?.message) {
//       return {
//         ok: false,
//         err: response.message,
//         rows: this.rawRows,
//         isPopulated: this.isPopulated,
//         message: response.message,
//       };
//     }

//   // Fallback: malformed response
//   return {
//     ok: false,
//     err: "Something Went Wrong",
//     message: "Something Went Wrong",
//     rows: this.rawRows,
//     isPopulated: this.isPopulated,
//   };


//     }

//   }

//   // if ((Array.isArray(rows) && rows.length == 0) || !rows || rows == null){
//         //   this.isPopulated = false
//         // }
//   //       if (Array.isArray(rows) && rows.length > 0) {
//   //         const updatedRows = this.HANDLE_ROWS(rows)
//   //         this.tableSchema.forEach((schema, index) => {
//   //           const {column, params} = schema
//   //           updatedRows.forEach((row: Row, rowIndex: number) => {
//   //             if (params.includes(numeric)){
//   //                 updatedRows[rowIndex][column] = Number(updatedRows[rowIndex][column])
//   //             } 
//   //           })
//   //         })

          
//   //         this.rawRows = [...updatedRows]
          
//   //         return { 
//   //           rows: this.rawRows,
//   //           ok: response.ok,
//   //           err: false,
//   //           message: response.message,
//   //           isPopulated: this.isPopulated,
//   //         };
//   //       } 
        
        
        
        
//   //       else {
//   //         return {
//   //           ok: false,
//   //           err: response.message,
//   //           rows: this.rawRows,
//   //           isPopulated: this.isPopulated,
//   //           message: response.message
//   //         }
//   //       }

//   //     } else {
//   //       return {
//   //         ok: false,
//   //         err: response.message,
//   //         rows: this.rawRows,
//   //         isPopulated: this.isPopulated,
//   //         message: response.message,
//   //       };
//   //     }
//   //   } else if (response?.message) {
//   //     return {
//   //       ok: false,
//   //       err: response.message,
//   //       message: response.message,
//   //       rows: this.rawRows,
//   //       isPopulated: this.isPopulated,
//   //     };
//   //   } else {
//   //     return {
//   //       ...response,
//   //       message: "Something Went Wrong",
//   //       rows: this.rawRows,
//   //     };
//   //   }
//   // };
// }
