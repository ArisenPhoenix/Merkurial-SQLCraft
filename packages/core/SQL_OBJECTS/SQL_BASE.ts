// Merkurial SQLCraft
// Copyright (c) 2025 Brandon M. Marcure
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.


import FETCH from "../../APIS/FETCH";
import {
  Schema,
  ForeignKeyMap,
  PrimaryKey,
  Messenger, 
  TableResponse,
  ColumnInput,
  None,
  Row,
  Rows,
  Value,
  RowEntry,
  Options,
  ColumnName,
  ColumnEntry
} from "../../type_defs/SQL_TYPES";

import QUERY_GENERATOR, {SQL_HELPERS} from "./QUERY_GENERATOR";

// const Q_GEN = new QUERY_GENERATOR();
 
import {
  getForeignKey,
  getPrimaryKey,
  paramsIncludeAutoGenId,
} from "../../helpers/checkAutoGenId";

import SQL_ROW from "./SQL_ROW";
import ARGS from "../../helpers/postgreArgs";
import { HttpMethod } from "../../type_defs/api";

const { numeric, jsonb, unique } = ARGS

type query = {query: string, type?: string | undefined}
type Properties = {}

export default class SQL_BASE {
  // Must Be Supplied
  tableName: string;
  tableSchema: Schema;
  callAddress: string;
  isPopulated: true | None;
  
  // Optionally Supplied
  messenger: Messenger | None;

  // Wiil Be Extrapolated From Schema
  primaryKey: PrimaryKey;
  columnNames: string[];
  foreignKeyColumnNames: string[];
  isIdAutoGenerated: string | false;
  containsArray: boolean;

  // Can Be Extrapolated Elsewhere
  foreignKeyMap: ForeignKeyMap | None;
  rawRows: Row[] | Array<Row>   // For batch operations and perhaps rollbacks
  sqlRows: SQL_ROW[] // For holding actual table data and output of said data

  returning: boolean
  deleting: boolean
  updating: boolean
  adding: boolean
  lastQuery: string | undefined

  constructor(
    tableName: string,
    tableSchema: Schema,
    callAddress: string,
    messenger: Messenger | None,
    primaryKey: PrimaryKey | null = null,
    foreignKeyMap: ForeignKeyMap | null | false = false,
    isIdAutoGenerated: string | false = false
    
  ) {
    this.tableName = tableName; 
    this.tableSchema = tableSchema;
    this.callAddress = callAddress;
    this.messenger = messenger;
    this.isPopulated = false;
    this.primaryKey = primaryKey;
    this.foreignKeyMap = foreignKeyMap == null ? {} : foreignKeyMap
    this.columnNames = [];
    this.foreignKeyColumnNames = [];
    this.isIdAutoGenerated = isIdAutoGenerated
    this.rawRows = []
    this.containsArray = false
    this.returning = false
    this.deleting = false
    this.updating = false
    this.adding = false
    this.construct();
    this.lastQuery = undefined
  }

  Q_GEN = new QUERY_GENERATOR();
  Helpers = new SQL_HELPERS();

  construct() {
    if (this.tableSchema.length > 0) {
      this.extrapolateData(this.tableSchema);
    }
  }

  properties = (): Properties => {
    const props = {
      tableName: this.tableName,
      tableSchema: this.tableSchema,
      callAddress: this.callAddress,
      primaryKey: this.primaryKey,
      foreignKeyMap: this.foreignKeyMap,
      columnNames: this.columnNames,
      foreignKeyColumnNames: this.foreignKeyColumnNames,
    }
    return props
  };

  private extrapolateData = (tableSchema: Schema) => {
    if (
      !this.primaryKey ||
      this.primaryKey == null ||
      !this.columnNames ||
      this.columnNames == null ||
      this.columnNames.length === 0 ||
      !this.foreignKeyColumnNames ||
      this.foreignKeyColumnNames == null || 
      this.foreignKeyColumnNames.length === 0 ||  
      !this.isIdAutoGenerated
    ) {
      tableSchema.forEach((columnData) => {
        // console.log(column)
        const {column, params} = columnData
        this.columnNames.push(column);
        const primaryKey = getPrimaryKey(params)
        const foreignKey = getForeignKey(params)
        if (JSON.stringify(params).includes("[]")){
          this.containsArray = true
        }
        if (foreignKey && primaryKey){
          throw Error("There Cannot Be Both A Primary Key And A Foreign Key Assigned To A Column")
        } else {
          if (this.primaryKey == null && primaryKey){
            this.primaryKey = column
            this.isIdAutoGenerated = paramsIncludeAutoGenId(params)
          } 
          else if (this.primaryKey && primaryKey) {
            throw new Error("A Table May Only Have Up To 1 Primary Key");
          } 
          if (foreignKey){
            this.foreignKeyColumnNames.push(column);
            this.foreignKeyColumnNames = new Array(...new Set(this.foreignKeyColumnNames))
            this.foreignKeyMap[column] = params;
          }
        }
        if (!this.primaryKey) {
          throw new Error("Your Table Must Contain A PRIMARY KEY");
        }
        
      });
    }
  };

  findRowByColumnsAndValues = async (arr: ColumnInput[], callAddress=this.callAddress, options: Options | undefined) => {

    let query = this.Helpers.compareAllColumnInputs(arr);
    query = this.HANDLE_SUPPLEMENTARY(query, options)
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      callAddress,
      "findRowByColumnsAndValues"
    );
    return response;
  };

  call = async (
    query: query,
    method: HttpMethod,
    address: string,
    callingFunction: string | null | undefined = null
  ) => {
    const response = await FETCH (
      address,
      method,
      { query: query.query, type: query.type },
      callingFunction
    );
    
    if (response.ok) {
      this.lastQuery = query.query
      // this.isPopulated = method !== "DELETE" ? true : false;
      if (this.messenger != null) {
        response.message &&
          this.messenger &&
          this.messenger(`Table ${this.tableName} ${response.message}`);
      }
      return response;
    }
  };

  

  query = async (
    query: query,
    method: HttpMethod = "POST",
    callAddress: string = this.callAddress,
    callingFunction: string = "SQL_BASE.query"
  ) => {
    const queryData = {query: query.query, type: query.type}
    const res = await this.call(
      queryData,
      method,
      callAddress,
      callingFunction
    );
    this.HANDLE_RESPONSE(res)

    return res;
  };

  getAtomicIdentifier(row: RowEntry): { column: string; value: any } {
    if (this.primaryKey && row[this.primaryKey] !== undefined) {
      return { column: this.primaryKey, value: row[this.primaryKey] };
    }
  
    for (const { column, params } of this.tableSchema) {
      if (params.includes(unique) && row[column] !== undefined) {
        return { column, value: row[column] };
      }
    }
  
    throw new Error("Row must contain a primary key or a unique column to perform an atomic delete.");
  }



  GET_UNIQUE_FROM_SCHEMA = (data: RowEntry) => {
    for (const entry in Object.keys(data)){
      if (unique in this.tableSchema[entry]){
        return entry
      }
    }
    return false
  }

  SET = (columnName: ColumnName, value: any, isJsonB: boolean) => {
    if (isJsonB){
      return `${columnName} = ${this.Q_GEN.HANDLE_INSERT_JSON_B(value)}`
    } else if (Array.isArray(value)){
      return `${columnName} = ${this.Q_GEN.HANDLE_INSERT_ARRAY(value)} `
    } 
    return `${columnName} = ${this.Q_GEN.HANDLE_INSERT_NUMBER_OR_STRING(value, `'`)} `
  }

  SETS = (itemsToSet: RowEntry, jsonColumnNames: string[] | undefined) => {
    let setQuery = this.UPDATE_ROW_STRING()
    const entries = Object.entries(itemsToSet)
    entries.forEach((entry, index) => {
      const isJsonB = jsonColumnNames.includes(entry[0])
      const addend = index === entries.length - 1 ? "" : ", ";
      setQuery += this.SET(entry[0], entry[1], isJsonB) + addend;
    })
    return setQuery
  }

  HANDLE_SUPPLEMENTARY = (initial_query: string, options: Options) => {
    let query = initial_query
    if (options.groupBy && typeof options.groupBy === "string") {
      query += ` GROUP BY "${options.groupBy}"`
    }
    if (options.orderBy && typeof options.orderBy === "string"){
      query += ` ORDER BY "${options.orderBy}"`
    }
    if (options.limit && typeof options.limit === "number"){
      query += ` LIMIT ${options.limit}`
    } if (options.returning && typeof options.returning === "string"){
      this.returning = true
      query += ` RETURNING ${options.returning}`
    }
    this.returning = false;
    return query
  }

  HANDLE_ROWS = (rows: Rows): any => {
    const ROWS_FINAL = rows.map((row: Row) => {
      let newRow = row
      if (this.containsArray){
        for (const column in row){
          const rowColumnValue = row[column]
          const UpdatedRowValue = this.Q_GEN.HANDLE_ARRAY_COLUMN_VALUES(rowColumnValue)
          newRow[column] = UpdatedRowValue
        }
      }  
      
      return newRow
  })

  
  return ROWS_FINAL
  
}

  DELETE_ROW_STRING = () => {
    const query = `DELETE FROM ${this.tableName} `
    return query
  }

  UPDATE_ROW_STRING = () => {
    const query = `UPDATE ${this.tableName} SET `
    return query
  }

  

  protected HANDLE_RESPONSE = (
    response: any,
    deleted: boolean = false,

  ): TableResponse => {
    const okay = response.ok
    // console.log("HANDLE_RESPONSE response: ", response)
    if (okay && Array.isArray(response.response?.rows)){
      const rows: Rows = response.response.rows;
      const error = response.response?.err ? response.response.err : false
      const message = response.response?.message ? response.response.message : false

     
      
      if (deleted) {
        this.isPopulated = false;
        return {
          rows,
          ok: okay,
          err: error,
          message: message || "Deleted successfully.",
          isPopulated: false,
        };
      }

      
      // if (response?.ok && response?.response?.rows) {
        this.isPopulated = (Array.isArray(rows) && rows.length > 0)
        const res: TableResponse = {ok: okay, rows: rows, err: error, message: message, isPopulated: this.isPopulated}

        if (!this.isPopulated) {
          res.message = "No rows returned"
        }
    
        const updatedRows = this.HANDLE_ROWS(rows);
    
        this.tableSchema.forEach(({ column, params }) => {
          if (params.includes(numeric)) {
            updatedRows.forEach((row: Row) => {
              row[column] = Number(row[column]);
            });
          }
        });
    
        this.rawRows = [...updatedRows];
      return res
    } else {
      return {
        ok: okay,
        err: "Response Failed",
        message: "Response Failed",
        rows: this.sqlRows,
        isPopulated: this.isPopulated
      }
    }
    
  };

}

