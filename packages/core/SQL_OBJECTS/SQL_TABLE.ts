// Merkurial SQLCraft
// Copyright (c) 2025 Brandon M. Marcure
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.



 
// import {CONVERT_CONSTRUCTOR_TO_CREATE_TABLE_IF_NOT_EXISTS} from "/packages/core/helpers/convertObjectToQuery";
import { CONVERT_CONSTRUCTOR_TO_CREATE_TABLE_IF_NOT_EXISTS } from "../../helpers/convertObjectToQuery";
import SQL_BASE from "./SQL_BASE";
import SQL_ROW from "./SQL_ROW";

import {
  Key,
  Row,
  Schema,
  ColumnInput,
  Messenger,
  ForeignKeyValuePair,
  ForeignKeyMap,
  Options,
  PrimaryKey,
  RowEntry,
  Rows
} from "../../type_defs/SQL_TYPES";

import ARGS from "../../helpers/postgreArgs";

export default class TABLE extends SQL_BASE {
  hasTable: boolean = false
  // sqlRows: SQL_ROW[]
  isIdAutoGenerated: string | false;

  constructor(
    tableName: string,
    callAddress: string, 
    tableSchema: Schema | null,
    messenger: Messenger | null | false,
    primaryKey: PrimaryKey | null = null,
    foreignKeyMap: ForeignKeyMap | null = null
  ) {
    super(tableName, tableSchema, callAddress, messenger, primaryKey, foreignKeyMap);
    this.sqlRows = []
  }

  get outputRows(): Row[] {
    const verifiedRows = this.sqlRows.map(row => row.rowData); // convert SQL_ROW to plain Row
    const rawIds = new Set(verifiedRows.map(row => row[this.primaryKey]));
  
    const leftovers = this.rawRows.filter(raw => {
      const rawId = raw[this.primaryKey];
      return !rawIds.has(rawId); // filter out rawRows that would clash with verified
    });
  
    return [...verifiedRows, ...leftovers]; // Combine both for UI output
  }

  CREATE_TABLE = async (foreignKeyMap: ForeignKeyMap = null) => {
    const query = CONVERT_CONSTRUCTOR_TO_CREATE_TABLE_IF_NOT_EXISTS(
      this.tableName,
      this.tableSchema,
      foreignKeyMap
    );

    console.log("CREATE_TABLE QUERY: ", query)

    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "SQL_TABLE.CREATE_TABLE"
    );

    return { ...response, hasTable: this.hasTable };
  };

  HAS_TABLE = async () => {
    if (!this.hasTable) {
      const tableData = await this.GET_TABLE();
      this.hasTable = tableData.isPopulated ? true : false;
      return this.hasTable
    }
    
    return this.hasTable;
    
  };

  DELETE_TABLE = async () => {
    const queryText = `DROP TABLE ${this.tableName}`;
    const response = await this.call(
      { query: queryText },
      "DELETE",
      this.callAddress,
      "SQL.DELETE_TABLE"
    );
    return { ...response, hasTable: this.hasTable };
  };

  GET_TABLE = async () => {
    const query = `SELECT * FROM ${this.tableName}`;
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      this.callAddress,
      "TABLE.GET_TABLE"
    );
    return response;
  };

  INITIALIZE_TABLE = async () => {
    const query = `SELECT * FROM ${this.tableName} LIMIT 1`;
    const response = await this.call(
      { query: query, type: "GET" },
      "POST",
      this.callAddress,
      "TABLE.INITIALIZE_TABLE"
    );
    // const data = this.HANDLE_RESPONSE(response);
    const data = response?.response?.rows
    return data;
  };

  /**
   * @param columnVals required - The values for the entry | must match schema value structure in length and type
   * @param callAddress optional - the address for making api calls to defaults to the same as the Table Class
   * @param messager optional - a call back function with a single parameter for returning a message back, defaults to the same as the Table Class
   * @returns a new table column class with it's own various methods
   */

  FindRowById = async (id: Key) => {
    const rowId =
      typeof id === "string" ? `'${id}'` : typeof id === "number" ? id : null;
    if (!rowId && rowId != 0) {
      throw new TypeError("That Id Is Not Of Type Number Nor String");
    }
    const query = `SELECT * FROM ${this.tableName} WHERE "${this.primaryKey}" = ${rowId}`;
    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "TABLE.FindRowById"
    );

    if (response.ok) {
      if (Array.isArray(response.rows) && response.rows.length > 0) {
        const rows = this.HANDLE_ROWS(response.rows)
        this.sqlRows = []
        for (let row of rows){
          
          this.sqlRows.push(new SQL_ROW(row, this.tableName, this.tableSchema, this.callAddress, this.messenger, this.primaryKey, this.foreignKeyMap, this.isIdAutoGenerated))
        }
        return response;
      } else {
        return null;
      }
    }
  };

  checkArgs = (args: ColumnInput) => {
    const argArr = Object.keys(args);
    argArr.forEach((argument, index) => {
      if (!this.tableSchema[argument]) {
        throw new Error(
          `You entered a column that does not exist within the current schema. at index ${index}`
        );
      }
    });
    return true;
  };

  SELECT_ALL = () => {
    return "SELECT * ";
  };

  FROM_TABLE = () => {
    return `FROM ${this.tableName} `;
  };

  SELECT_ALL_BY_FOREIGN_KEY_MATCH = async (
    foreignKeyValuePair: ForeignKeyValuePair, options: Options | undefined
  ) => {
    const selectedFk = Object.keys(foreignKeyValuePair)[0];
    const value = foreignKeyValuePair[selectedFk];

    let query = this.SELECT_ALL() + this.FROM_TABLE();
    query += "WHERE " + this.Where(selectedFk, value);
    
    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query

    const res = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "Row.FindRowById"
    );

    const data = this.HANDLE_RESPONSE(res);
    return data;
    
  };

  selectedColumns = (args: ColumnInput) => {
    let query = "";
    const entries = Object.entries(args);
    entries.forEach((entry, index) => {
      const [column, value] = entry;
      if (!this.tableSchema[column]) {
        throw new Error(
          `Column ${column} does not exist on table ${this.tableName}. `
        );
      }
      const addend = index === entries.length - 1 ? "" : ", ";
      query += `"${column}${addend}"`;
    });
    return query;
  };

  SelectAllByValues = async (object: ColumnInput, options: Options | undefined) => {

    const WHERES = this.Wheres(object);
    let query = `SELECT * FROM ${this.tableName} ${WHERES}`;
    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query
    console.log("Final Query: ", query)

    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "SQL.SelectAllByValues"
    );
    const data = this.HANDLE_RESPONSE(response);
    return data;
  };

  SelectBySelectColumnsAndValues = async (object: ColumnInput, options: Options | undefined) => {
    const WHERES = this.Wheres(object);
    const Selected = this.selectedColumns(object);
    let query = `SELECT ${Selected} FROM ${this.tableName} ${WHERES}`;
    query = options ?  this.HANDLE_SUPPLEMENTARY(query, options) : query

    const response = await this.call(
      { query: query },
      "POST",
      this.callAddress,
      "SQL.SelectBySelectColumnsAndValues"
    );
    const data = this.HANDLE_RESPONSE(response);
    return data;
  };

  UPDATE_TABLE = async(query: string | undefined = this.lastQuery) => {
    if (typeof this.lastQuery == "string") {
      const res = await this.call({query: query ? query : this.lastQuery, type: "POST"}, "POST", this.callAddress, "SQL_TABLE.UPDATE_TABLE")
      // const data = this.HANDLE_RESPONSE(res)
      return res
    }
  }

  GENERATE_SQL_ROWS = (rows: Rows): Rows => {
      this.sqlRows = []
  
      rows.map((row, index) => {
        this.sqlRows.push(
          new SQL_ROW(row, this.tableName, this.tableSchema, this.callAddress, 
          this.messenger, this.primaryKey, this.foreignKeyMap, this.isIdAutoGenerated)
        )
      })
      return this.sqlRows
    }

  getClashingIds = (): (string | number)[] => {
    const ids = new Set(this.sqlRows.map(row => row.rowData[this.primaryKey]));
    return Array.from(ids);
  }
  
  removeClashingRawRows = () => {
    const clashingIds = this.getClashingIds();
    const filtered = this.rawRows.filter(row => !clashingIds.includes(row[this.primaryKey]));
    this.rawRows = filtered;
  } 
  
  removeFromRawRowsById(id: string | number) {
    this.rawRows = this.rawRows.filter(row => row[this.primaryKey] !== id);
  }

  fixSqlRows(): SQL_ROW[] {
    this.sqlRows = [...this.sqlRows, ...this.rawRows.map((rawRow: Row) => {
      return new SQL_ROW(rawRow, this.tableName, this.tableSchema, this.callAddress, this.messenger, 
        this.primaryKey, this.foreignKeyMap, this.isIdAutoGenerated)}
    )]
    this.isPopulated = (Array.isArray(this.sqlRows) && this.sqlRows.length > 0)
    this.rawRows = []
    return this.sqlRows
  }

  initializeTable = async() => {
    const res = await this.GET_TABLE();
    if (res.ok && Array.isArray(res.rows)) {
      this.rawRows = res.rows;
    }
    // let result = this.HANDLE_RESPONSE(res)
    // result.rows = this.fixSqlRows()
    // return this.HANDLE_RESPONSE(res);
    return res

  }


  SYNC_TABLE = async() => {
    let query = this.SELECT_ALL() + " " + this.FROM_TABLE();
    const res = await this.call({query: query, type: "GET"}, "GET", this.callAddress, "SQL.SYNC_TABLE");
    if (res?.rows){
      this.GENERATE_SQL_ROWS(res.rows)
    }
    return this.outputRows
  }

}




