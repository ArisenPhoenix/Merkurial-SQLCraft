// Merkurial SQLCraft
// Copyright (c) 2025 Brandon M. Marcure
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

 


import SQL_BASE from "./SQL_BASE";
import {
  ForeignKeyMap,
  PrimaryKey,
  Schema,
  None,
  RowEntry, 
  Messenger, 
  Value,
  Options
} from "packages/type_defs/SQL_TYPES";
import {
  getPrimaryKey,
  paramsIncludeAutoGenId,
} from "../../helpers/checkAutoGenId" //"@helpers/checkAutoGenId"; 
import ARGS from "../../helpers/postgreArgs"  //"@helpers/postgreArgs";

export default class SQL_ROW extends SQL_BASE {
  isRow: boolean;
  rowData: {};
  rowValues: Value[];
  isIdAutoGenerated: string | false
  jsonColumns: number[]
  jsonColumnNames: string[]
  constructor(
    rowEntryData: RowEntry,
    tableName: string,
    tableSchema: Schema,  
    callAddress: string, 
    messenger: Messenger | null | false,
    primaryKey: PrimaryKey | null | undefined = null,
    foreignKeyMap: ForeignKeyMap | None = null,
    isIdAutoGenerated: string | false = false
  ) {
    super(
      tableName,
      tableSchema,
      callAddress,
      messenger,
      primaryKey,
      foreignKeyMap,
      isIdAutoGenerated
    ); 

    // New Values Added To Row Class
    this.isRow = false;
    this.rowData = rowEntryData
    this.rowValues = [];

    // Row Class Values
    this.primaryKey = primaryKey; 
    this.foreignKeyMap = foreignKeyMap; 
    this.isIdAutoGenerated = isIdAutoGenerated ? isIdAutoGenerated : this.isIdAutoGenerated
    this.jsonColumns = []
    this.jsonColumnNames = []

    // INIT
    this.construct()
    this.checkColumnNamesMatch();
    this.checkJsonColumns()
    
  } 


  checkJsonColumns = (tableSchema: Schema = this.tableSchema) => {
    tableSchema.forEach((schema, index) => {
      const {column, params} = schema
      if (params.includes(ARGS.jsonb)){
        this.jsonColumns.push(this.isIdAutoGenerated ? index -1 : index)
        this.jsonColumnNames.push(column)
      }
  })

}

  checkColumnNamesMatch = () => {
    for (let schema of this.tableSchema) {
      const { column, params } = schema;
      if (!this.rowData[column] && !this.rowData[column] == false && !paramsIncludeAutoGenId(params)) {
        throw Error(
          `The Column Name ${column} Was Not Present In The Row Data Supplied For Table ${this.tableName}` 
        );
      }
    }
    this.properties
  };

  compareAllColumns = () => {
    const colNames = this.columnNames;
    const colVals = this.rowValues;
    let text = "";
    for (let i = 0; i < colNames.length; i++) {
      const col = colNames[i];
      const value = colVals[i];
      const addend = i === colNames.length - 1 ? "" : "AND";
      text += `"${col}" = '${value}' ${addend} `;
    }
    return text;
  };

  getIdByAllValuesQuery = () => {
    const allCompared = this.compareAllColumns();
    const query = `SELECT ${this.primaryKey} FROM ${this.tableName} WHERE ${allCompared}`;
    return query;
  };

  getKeys(tableSchema: Schema = this.tableSchema) {
    if (tableSchema && this.primaryKey == null) {
      tableSchema.forEach((schema) => {
        const {column, params} = schema
        this.columnNames.push(column);
        if (params.includes(ARGS.primaryKey)){
          if (this.primaryKey === null) {
            this.primaryKey = column;
          } else {
            throw new Error("A Table May Only Have Up To 1 Primary Key");
          }
        }
        

        if (params.includes(ARGS.foreignKey)){
          console.log(`ARG ${column} Is A Foreign Key`)
          this.foreignKeyColumnNames.push(column); 
        }
      });
    } 
    if (!this.primaryKey) {
      throw new Error("Your Table Must Contain A PRIMARY KEY");
    } 
  } 
 

  INSERT_VALUES = () => {
    let values = this.rowValues
    let valuesString = ` VALUES ( `
    valuesString += this.isIdAutoGenerated && this.adding ? "DEFAULT, " : ""
    valuesString += this.Q_GEN.HANDLE_INSERT_ARRAY_DATA(values, `'`, this.jsonColumns)
    return valuesString + ") "
  }

  INSERT_COLUMNS = () => {
    let columns = this.columnNames 
    if (this.isIdAutoGenerated && this.adding){
      columns.splice(0, 0, this.primaryKey)
    }
    
    let columnsString = "( "
    columnsString += this.Q_GEN.HANDLE_INSERT_ARRAY_DATA(columns, `"`)
    return columnsString += " )"
  }

  INSERT_STRING = () => { 
    const query = `INSERT INTO "${this.tableName}" `
    return query 
  }


  add = async (options: Options | undefined, force: Boolean = false) => {
    this.returning = true
    if (force){
      // This checks for a non-default value being included. It changes the adding flag, to force the getAddQueryString to not use the default
      if (Object.keys(this.rowData).includes(this.primaryKey)){
        if (!this.rowData[this.primaryKey]){
          throw Error("They Key <" + this.primaryKey + ">" + "must contain a value")
        } else {
          this.adding = false
        }
      }
    }
    
    let query = this.getAddRowQueryString();
    this.adding = true;

    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query
    // console.log("QUERY FOR SQL_ROW.add: ", query);

    const response = await this.call(  
      { query: query, type: "GET" },
      "POST",
      this.callAddress,
      "SQL_ROW.add"
    );
    const data = this.HANDLE_RESPONSE(response)
    this.adding = false
    this.returning = false
    return data
  };

  remove = async (options: Options | undefined) => {
    let query = this.getRemoveRowQueryString()
    this.returning = true
    this.deleting = true

    
    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query
    const response = await this.call( 
      { query: query, type: "DELETE" },
      "DELETE",
      this.callAddress,
      "SQL_ROW.remove"
    );

    this.deleting = false
    this.returning = false
    return response
  }

  update = async (options: Options | undefined) => {    
    console.log("SQL_ROW.update RowData: ", this.rowData)
    let primaryKey = this.primaryKey
    let primaryKeyValue = this.rowData[primaryKey]
    if (!primaryKeyValue){
      const {column: tempKey, value: tempValue} = this.getAtomicIdentifier(this.rowData)
      console.log("NEW primaryKey: ", tempKey)
      if (tempKey){
        primaryKey = tempKey
        console.log("NEW primaryKey: ", primaryKey)
        primaryKeyValue = this.rowData[primaryKey]
      }
      else {
        console.log("NEW primaryKey: ", primaryKey)
        throw Error("Cannot Update A Row with an undefined key value pair")
      }
    }

    console.log("SQL_ROW.update PrinaryKey: ", primaryKey)
    console.log("SQL_RW primaryKeyValue", primaryKeyValue)
    
    const temp = {...this.rowData}
    delete temp[primaryKey]
    this.returning = true
    this.updating = true

    let query = this.SETS(temp, this.jsonColumnNames)
    query += this.Q_GEN.Wheres({[primaryKey]: primaryKeyValue})

    query = options ? this.HANDLE_SUPPLEMENTARY(query, options) : query
    console.log("SQL_ROW.update Query: ", query)

    const response = await this.call( 
      { query: query, type: "PUT" },
      "PUT",
      this.callAddress,
      "SQL_ROW.update"
    );



    this.returning = false
    this.updating = false
    return response
}

  getAddRowQueryString = () => {
    let query = this.INSERT_STRING()
    query += this.INSERT_COLUMNS()
    query += this.INSERT_VALUES()
    return query
  }

  getRemoveRowQueryString = () => {
    let query = this.DELETE_ROW_STRING() + this.Q_GEN.Wheres(this.rowData)
    return query
  }

  getUpdateRowQueryString = () => {
    let query = this.UPDATE_ROW_STRING() + this.SETS(this.rowData, this.columnNames)
    return query
  }

 
  

  

  private extrapolateRowData() {
    if (this.rowData){
      const rowDataKeys = Object.keys(this.rowData);
      if (rowDataKeys.length > 0) {
        this.columnNames = rowDataKeys;
        this.rowValues = Object.values(this.rowData);
      
      } else if (this.rowValues) {
      }
    }
    
  }

  construct(tableSchema: Schema = this.tableSchema) {
    if (tableSchema) {
      if (this.rowData){
        this.extrapolateRowData();
        this.getKeys();  
      }
      
    }
  }

}
