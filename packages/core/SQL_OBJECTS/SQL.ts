// Merkurial SQLCraft
// Copyright (c) 2025 Brandon M. Marcure
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.


 




import TABLE from "./SQL_TABLE";
import SQL_ROW from "./SQL_ROW"
import { Row, Messenger, Schema, Value, Params, ColumnName, RowEntry, None, Options, ForeignKeyMap } from "../../type_defs/SQL_TYPES";
import SQL_COLUMN from "./SQL_COLUMN"


class SQL_TABLE extends TABLE {
    isRow: boolean

    constructor( 
        tableName: string,
        callAddress: string,
        tableSchema: Schema | null,
        messenger: Messenger | None,
        foreignKeyMap: ForeignKeyMap | null = null
    ) {
        super(tableName, callAddress, tableSchema, messenger, null, foreignKeyMap);
    }


    newRow = (
      rowEntryData: RowEntry, 
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger) => {
      if (this.primaryKey && rowEntryData != null && rowEntryData){
          const row = new SQL_ROW(
              rowEntryData,
              this.tableName,
              this.tableSchema, 
              callAddress,
              messenger, 
              this.primaryKey, 
              this.foreignKeyMap,
              this.isIdAutoGenerated
              )
          return row
      } else {
        throw Error("All The Required Data Was Not There")
      }
    }

    // submitRow = async(row: RowEntry, options: Options) => {
    //   this.rawRows.push(row); // show in UI instantly
    //   await this.addRow(row, options).then(res => {
    //     if (Array.isArray(res) && res.length > -1) {
    //       // cleanup rawRow & push to sqlRows inside addRow
    //     }
    //   });
    // }
    getRowMatch = (row: RowEntry) => {
      const ID = this.primaryKey
      console.log("getRowMatch This.primaryKey: ", this.primaryKey)
      if (!Array.isArray(row) && typeof row == "object") {
        // const modifiedRow = row
        let matchIndex = this.rawRows.findIndex((checkRow, index) => {
          return checkRow[ID] == row[ID]
        })

        console.log("getRowMatch, index: ", matchIndex)
        if (!(matchIndex > -1)){
          const {column: secondaryID, value: val} = this.getAtomicIdentifier(row)
          console.log("SECONDARY ID: ", secondaryID)
          matchIndex = this.rawRows.findIndex((checkRow, index) => {
            return row[secondaryID] == checkRow[secondaryID];
          })
        }
        return matchIndex
      }
      

      return false
    }


  

    addRow = async (
      rowEntryData: RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.adding = true
        this.returning = true
        
        const row = this.newRow(rowEntryData, callAddress, messenger)
        this.rawRows = [...this.rawRows, rowEntryData];
        let force = false;
        for (const key in Object.keys(rowEntryData)){
          if (key == this.primaryKey){
            force = true;
            break
          }
        }
        const rowRes = await row.add(options, force);

        if (Array.isArray(rowRes.rows) && rowRes.rows.length > 0) {
          const confirmedRow = rowRes.rows[0];
          
          this.moveRawToConfirmed(confirmedRow);
          this.returning = false
          this.adding = false
          return this.outputRows
        }
    }

    addRows = async (
      rowEntries: RowEntry[],
      options: Options
    ): Promise<Row[]> => {
      for (const row of rowEntries) {
        await this.addRow(row, options);
      }
      return this.outputRows;
    }

    deleteRow = async (
      rowEntryData: Row | RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger | null | false = this.messenger
    ): Promise<Row[] | false> => {
      let key = this.primaryKey
      if (!(key in rowEntryData)) {
        // if primary key isn't present, another unique value can be used.
        const {column, value} = this.getAtomicIdentifier(rowEntryData)
        if (column != key){
          key = column
        }
      }

      
      this.deleting = true;
      this.returning = true;
    
      const row = this.newRow(rowEntryData, callAddress, messenger);
      const rowRes = await row.remove(options);
      // this.HANDLE_RESPONSE(rowRes, true)

      console.log("deleteRow response: ", rowRes);
    
      if (Array.isArray(rowRes.rows) && rowRes.rows.length > 0) {
        const deletedRow = rowRes.rows[0];
        const deletedId = deletedRow[key];
        // const intendedId = rowEntryData[this.primaryKey];
        const intendedId = row.rowData[key];

    
        const deleteSuccess = deletedId === intendedId;
    
        if (!deleteSuccess) {
          console.error(
            `[SQL_TABLE.deleteRow] Deletion mismatch: expected ID ${intendedId}, but got ${deletedId}`
          );
          this.deleting = false;
          this.returning = false;
          throw new Error("Deletion mismatch: state may be inconsistent.");
        }
    
        // Confirmed deletion, remove from sqlRows
        const sqlIndex = this.sqlRows.findIndex(r => r.rowData[key] === deletedId);
        if (sqlIndex > -1) {
          const tempSQL = [...this.sqlRows];
          tempSQL.splice(sqlIndex, 1);
          this.sqlRows = tempSQL;
        }
    
        // Also remove from rawRows (if still present)
        this.rawRows = this.rawRows.filter(r => r[key] !== deletedId);
        console.log("Rows Before deleteRow->HANDLE_RESPONSE: ", this.sqlRows)

        this.deleting = false;
        this.returning = false;
        return this.outputRows;
      }
    
      // Fallback: remove from rawRows if unverified
      const fallbackIndex = this.rawRows.findIndex(r => r[key] === rowEntryData[key]);
      if (fallbackIndex > -1) {
        const tempRaw = [...this.rawRows];
        tempRaw.splice(fallbackIndex, 1);
        this.rawRows = tempRaw;
    
        this.deleting = false;
        this.returning = false;
        return this.outputRows;
      }
    
      this.deleting = false;
      this.returning = false;
      return false;
    };
    
    

    deleteRowByAnyColumns = async (
      rowEntryData: Row | RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger,
    ) => {
      this.deleting = true
      this.returning = true
      options = options ? options :{"returning": "*"} 
      const newRow = this.newRow(rowEntryData, callAddress, messenger)
      const rowDelResponse = await newRow.remove(options)
      if (rowDelResponse.rows.length > 0){
        const rowData = rowDelResponse.rows[0]
        const matchIndex = this.getRowMatch(rowData)
        const temp = this.rawRows.slice()
        if (typeof matchIndex === "number" && matchIndex > -1) {
          temp.splice(matchIndex, 1)
          this.rawRows = [...temp]
          return this.outputRows
        } else {
          // console.log("Match of Row Failed")
          return false
        }
      } else {
        // console.log("Deletion of Row Failed")
        return false
      } 
      
    }

    updateRow = async (
      rowEntryData: RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.updating = true
        this.returning = true
        const matchIndex = this.getRowMatch(rowEntryData)
        console.log("updateRow matchIndex: ", matchIndex)

        if (typeof matchIndex == "number" && matchIndex > -1){
          const row = this.newRow(rowEntryData, callAddress, messenger)
          const rowRes = await row.update(options)
          const updateSuccess = JSON.stringify(rowRes.rows[0]) == JSON.stringify(rowEntryData)
          if (updateSuccess){
            const temp = this.rawRows.slice()
            temp[matchIndex] = rowEntryData
            this.rawRows = [...temp]
            this.updating = false
            this.returning = false
            return this.outputRows
          }
        }

        this.updating = false
        this.returning = false
        return false
      } 
    
    updateRowByAnyColumns = async (
      rowEntryData: RowEntry,
      options: Options,
      callAddress: string = this.callAddress, 
      messenger: Messenger|null|false = this.messenger, 
      ) => {
        this.updating = true
        this.returning = true
        const matchIndex = this.getRowMatch(rowEntryData)
        if (typeof matchIndex === "number" && matchIndex > -1){
          const newRow = this.newRow(rowEntryData, callAddress, messenger)
          const rowUpdateRes = await newRow.update(options)
        if (rowUpdateRes.rows?.length > 0){
          const temp = this.rawRows.slice()
          const rowToUpdate = temp[matchIndex]
          const finalRowData = {...rowToUpdate, ...rowEntryData} 
          this.rawRows = [...temp]
          this.rawRows.splice(matchIndex, 1, finalRowData)
          this.rawRows = [...this.rawRows]
          return this.outputRows
        } else {
            console.log("Update By Any Was Unsuccessful")
            this.updating = false
            this.returning = false
            return false
        }
      } else {
          console.log("The ID Provided Did Not Match Any Row Ids")
          this.updating = false
          this.returning = false
          return false
        
      }
    }

    

    addColumn = (columnName: ColumnName, params: Params, defaultValue: Value) => {
      const column = new SQL_COLUMN(this.tableName, columnName, params)
      return column
      }
  }

export default SQL_TABLE






